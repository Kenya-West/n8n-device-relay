{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "device-relay",
        "options": {}
      },
      "id": "b23b7b06-a159-4425-af22-7186007550d7",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -960,
        576
      ],
      "webhookId": "fe4a40f7-acfa-4380-99d1-72c4b7c7ca34"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -416,
        736
      ],
      "id": "1d02a08e-b465-4bcc-8f1d-251d34b12ae7",
      "name": "Merge"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "{}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -592,
        736
      ],
      "id": "fe78a809-f10c-48c4-a6a8-5bb70f427990",
      "name": "Config"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (Run Once for All Items)\n\n// Toggle this to silence logs quickly\nconst DEBUG = true;\n\nconst log = (...args) => {\n  if (DEBUG) console.log(\"[debug]\", ...args);\n};\n\nconst redact = (value) => {\n  const SECRET_KEY_RE = /(token|secret|password|apiKey|key)/i;\n\n  const walk = (v) => {\n    if (v == null) return v;\n    if (Array.isArray(v)) return v.map(walk);\n\n    if (typeof v === \"object\") {\n      const out = {};\n      for (const [k, child] of Object.entries(v)) {\n        if (SECRET_KEY_RE.test(k)) out[k] = \"***REDACTED***\";\n        else out[k] = walk(child);\n      }\n      return out;\n    }\n\n    return v;\n  };\n\n  return walk(value);\n};\n\nlog(\"Input item count:\", $input.all().length);\n\nconst wrapper = $input.first().json;\nlog(\"Wrapper keys:\", Object.keys(wrapper ?? {}));\n\nconst config = wrapper.config;\nconst event = wrapper.event;\nconst recipientsResolved = wrapper.recipientsResolved;\n\nlog(\"Has config?\", !!config, \"Has event?\", !!event);\nlog(\"Config (redacted):\", redact(config));\nlog(\"Event keys:\", Object.keys(event ?? {}));\nlog(\"Event.body keys:\", Object.keys(event?.body ?? {}));\n\nif (!config) throw new Error(\"Missing config\");\nif (!event) throw new Error(\"Missing event\");\nif (!recipientsResolved) throw new Error(\"Missing RecipientsResolved\");\nif (!config?.recipients) throw new Error(\"Missing config.recipients (ConfigModel)\");\nif (!config?.endpoints) throw new Error(\"Missing config.endpoints (ConfigModel)\");\nif (!config?.templates) throw new Error(\"Missing config.templates (ConfigModel)\");\nif (!event?.body?.data?.type)\n  throw new Error(\"Missing event.body.data.type (InboundDataModel discriminator)\");\nif (!event?.body?.device.id) throw new Error(\"Missing event.body.device.id\");\nif (!event?.body?.id) throw new Error(\"Missing event.body.id (eventId)\");\n\nconst deviceId = event.body.device.id;\nconst dataType = event.body.data.type;\nconst eventId = event.body.id;\n\nlog(\"deviceId:\", deviceId);\nlog(\"dataType:\", dataType);\nlog(\"eventId:\", eventId);\n\n// meta is what templates typically refer to as {meta.*}\nconst meta = {\n  id: event.body.id,\n  createdAt: event.body.createdAt,\n  deviceId: event.body.deviceId,\n  source: event.body.source,\n  ...(event.body.meta ?? {}),\n};\nlog(\"meta:\", meta);\n\nconst ensureAllExist = (kind, ids, registry) => {\n  for (const id of ids) {\n    if (!registry[id]) {\n      throw new Error(`Unknown ${kind} id \"${id}\" referenced by routing logic`);\n    }\n  }\n};\n\n// Build OutboundDispatchPlan from config + event\nconst dispatches = [];\n/**\n * @type {Array<Object>}\n */\nconst recipients = recipientsResolved;\n\nlog(\"recipient ids:\", recipients.map((r) => r.id).flat().join(\", \"));\n\nfor (const recipient of recipientsResolved) {\n  const recipientId = recipient.id;\n\n  if (!Array.isArray(recipient.rules)) continue;\n\n  for (const rule of recipient.rules) {\n    const endpointIds = rule.then?.endpointIds ?? [];\n    const templateIds = rule.then?.templateIds ?? [];\n\n    if (endpointIds.length === 0 || templateIds.length === 0) continue;\n\n    ensureAllExist(\"endpoint\", endpointIds, config.endpoints);\n    ensureAllExist(\"template\", templateIds, config.templates);\n\n    for (const endpointId of endpointIds) {\n      for (const templateId of templateIds) {\n        dispatches.push({\n          id: `${eventId}:${recipientId}:${rule.id}:${endpointId}:${templateId}`,\n          recipientId,\n          ruleId: rule.id,\n          endpointId,\n          templateId,\n          matchedRuleIds: [rule.id],\n        });\n      }\n    }\n  }\n}\n\nconst outbound = {\n  eventId,\n  deviceId,\n  dataType,\n  configVersion: config.version,\n  dispatches,\n};\n\nlog(\"dispatches count:\", dispatches.length);\nlog(\"outbound:\", redact(outbound));\n\n// Return RuntimeModel\nreturn [\n  {\n    json: {\n      event,\n      config,\n      outbound,\n    },\n  },\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -96,
        1504
      ],
      "id": "68f520b0-b024-4375-b12a-3f3de25c5619",
      "name": "Form outbound",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (Run Once for All Items)\n\n// Toggle this to silence logs quickly\nconst DEBUG = true;\n\nconst log = (...args) => {\n  if (DEBUG) console.log(\"[debug]\", ...args);\n};\n\nconst redact = (value) => {\n  const SECRET_KEY_RE = /(token|secret|password|apiKey|key)/i;\n\n  const walk = (v) => {\n    if (v == null) return v;\n    if (Array.isArray(v)) return v.map(walk);\n\n    if (typeof v === \"object\") {\n      const out = {};\n      for (const [k, child] of Object.entries(v)) {\n        if (SECRET_KEY_RE.test(k)) out[k] = \"***REDACTED***\";\n        else out[k] = walk(child);\n      }\n      return out;\n    }\n\n    return v;\n  };\n\n  return walk(value);\n};\n\nconst wrapper = $input.first().json;\n\nconst config = wrapper.config;\nconst event = wrapper.event;\nconst outbound = wrapper.outbound;\n\nlog(\"Has config?\", !!config, \"Has event?\", !!event, \"Has outbound?\", !!outbound);\nlog(\"Outbound (redacted):\", redact(outbound));\n\nif (!config) throw new Error(\"Missing config\");\nif (!event) throw new Error(\"Missing event\");\nif (!outbound) throw new Error(\"Missing outbound\");\nif (!config?.recipients) throw new Error(\"Missing config.recipients (ConfigModel)\");\nif (!config?.endpoints) throw new Error(\"Missing config.endpoints (ConfigModel)\");\nif (!config?.templates) throw new Error(\"Missing config.templates (ConfigModel)\");\nif (!Array.isArray(outbound?.dispatches)) throw new Error(\"Missing outbound.dispatches\");\nif (!event?.body?.data?.type) throw new Error(\"Missing event.body.data.type\");\nif (!event?.body?.device.id) throw new Error(\"Missing event.body.device.id\");\nif (!event?.body?.id) throw new Error(\"Missing event.body.id\");\n\nconst meta = {\n  id: event.body.id,\n  createdAt: event.body.createdAt,\n  deviceId: event.body.device.id,\n  source: event.body.source,\n  ...(event.body.meta ?? {}),\n};\n\nconst mergeHeaders = (base, override) => ({\n  ...(base || {}),\n  ...(override || {}),\n});\n\nconst ensure = (kind, id, value) => {\n  if (!value) throw new Error(`Unknown ${kind} id \"${id}\"`);\n  return value;\n};\n\nconst defaultTimeoutMs = config?.defaults?.httpTimeoutMs;\nconst defaultHeaders = config?.defaults?.headers;\n\nlog(\"dispatch count:\", outbound.dispatches.length);\n\nconst items = outbound.dispatches.map((dispatch) => {\n  const recipientId = dispatch.recipientId;\n  const endpointId = dispatch.endpointId;\n  const templateId = dispatch.templateId;\n\n  const recipient = ensure(\"recipient\", recipientId, config.recipients[recipientId]);\n  const endpoint = ensure(\"endpoint\", endpointId, config.endpoints[endpointId]);\n  const template = ensure(\"template\", templateId, config.templates[templateId]);\n\n  // IMPORTANT: no templating here. Leave placeholders as-is.\n  // This node only adds metadata for later templating nodes.\n  if (endpoint?.body?.type && endpoint.body.type !== \"json\") {\n    throw new Error(\n      `Endpoint \"${endpointId}\" body.type=\"${endpoint.body.type}\" is not supported by this node (expects \"json\")`\n    );\n  }\n\n  return {\n    json: {\n      event,\n      config,\n      // metadata for later nodes that will do templating/rendering\n      templateData: {\n        meta, // typical {meta.*} namespace\n        data: event.body.data, // typical {data.*} namespace\n        device: event.body.device, // typical {data.*} namespace\n        recipient: {\n          id: recipientId,\n          vars: recipient.vars, // typical {recipient.vars.*} namespace\n        }\n      },\n      toTemplate: {\n        template: {\n          id: templateId,\n          text: template.text, // where `{message}` (or similar) should come from later\n          format: template.format,\n          fields: template.fields,\n        },\n        endpoint: endpoint\n      },\n    },\n  };\n});\n\nlog(\"Prepared items:\", items.length);\nlog(\"First item preview (redacted):\", redact(items[0]?.json));\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        1504
      ],
      "id": "d6ccb718-e616-4044-bff3-2c4f405cc867",
      "name": "Compose messages",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (Run Once for All Items)\n\n// Toggle this to silence logs quickly\nconst DEBUG = true;\n\nconst log = (...args) => {\n  if (DEBUG) console.log('[debug]', ...args);\n};\n\nconst redact = (value) => {\n  const SECRET_KEY_RE = /(token|secret|password|apiKey|key)/i;\n\n  const walk = (v, path = '') => {\n    if (v == null) return v;\n\n    if (Array.isArray(v)) return v.map((x, i) => walk(x, `${path}[${i}]`));\n\n    if (typeof v === 'object') {\n      const out = {};\n      for (const [k, child] of Object.entries(v)) {\n        const full = path ? `${path}.${k}` : k;\n        if (SECRET_KEY_RE.test(k)) out[k] = '***REDACTED***';\n        else out[k] = walk(child, full);\n      }\n      return out;\n    }\n\n    return v;\n  };\n\n  return walk(value);\n};\n\nlog('Input item count:', $input.all().length);\n\nconst wrapper = $input.first().json;\nlog('Wrapper keys:', Object.keys(wrapper ?? {}));\n\n// Allow common shapes: {config, event}, {config, body}, or direct webhook body\nconst config = wrapper.config;\nconst event = wrapper.event;\nconst recipientsFilteredGlobally = wrapper.recipientsFilteredGlobally;\n\nlog('Has config?', !!config, 'Has event?', !!event);\nlog('Config (redacted):', redact(config));\nlog('Event keys:', Object.keys(event ?? {}));\nlog('Event.body keys:', Object.keys(event?.body ?? {}));\n\nif (!recipientsFilteredGlobally) throw new Error('Missing recipientsFilteredGlobally');\nif (!config?.recipients) throw new Error('Missing config.recipients (ConfigModel)');\nif (!event?.body?.data?.type) throw new Error('Missing event.body.data.type (IncomingDataModel discriminator)');\nif (!event?.body?.device.id) throw new Error('Missing event.body.device.id');\n\nconst deviceId = event.body.device.id;\nconst dataType = event.body.data.type;\n\nlog('deviceId:', deviceId);\nlog('dataType:', dataType);\n\n// meta is what templates typically refer to as {meta.*}\nconst meta = {\n  id: event.body.id,\n  createdAt: event.body.createdAt,\n  deviceId: event.body.device.id,\n  source: event.body.source,\n  ...(event.body.meta ?? {}),\n};\nlog('meta:', meta);\n\nconst isPresent = (v) => v !== undefined && v !== null;\n\n/**\n  * If the value is a string, convert it to lowercase.\n  * Otherwise, return the value as is.\n  * @param {unknown} v - The value to be checked and potentially converted.\n  * @returns {unknown | string} - The lowercase string or the original value.\n */\nconst normalizeIfString = (v) => {\n  if (typeof v === 'string') {\n    return v.trim().toLowerCase();\n  }\n  return v;\n}\n\n/**\n * Convert a value to a comparable number if possible.\n * @param {unknown} v - The value to be converted.\n * @returns {number | undefined} - The comparable number or undefined if conversion is not possible.\n */\nconst toComparableNumber = (v) => {\n  if (typeof v === 'number' && Number.isFinite(v)) return v;\n  if (typeof v === 'string' && normalizeIfString(v) !== '') {\n    const n = Number(v);\n    return Number.isFinite(n) ? n : undefined;\n  }\n  return undefined;\n};\n\nconst normalizeEquals = (actual, expected) => {\n  log('normalizeEquals:', { actual, expected, actualType: typeof actual, expectedType: typeof expected });\n\n  if (!isPresent(actual) && !isPresent(expected)) return true;\n\n  if (typeof actual === 'boolean') {\n    if (typeof expected === 'boolean') return actual === expected;\n    if (typeof expected === 'string') {\n      const s = normalizeIfString(expected);\n      if (s === 'true') return actual === true;\n      if (s === 'false') return actual === false;\n    }\n    return false;\n  }\n\n  if (typeof actual === 'number') {\n    const n = toComparableNumber(expected);\n    return n !== undefined ? actual === n : false;\n  }\n\n  return normalizeIfString(String(actual)) === normalizeIfString(String(expected));\n};\n\nconst getByPath = (root, path) => {\n  const parts = (path ? String(normalizeIfString(path)) : '')\n    .split('.')\n    .filter(Boolean);\n\n  let cur = root;\n  for (const part of parts) {\n    if (cur == null) return undefined;\n    cur = cur[part];\n  }\n  return cur;\n};\n\n// Uses \"operator\" (your current my.json)\nconst predicateMatches = (predicate) => {\n  const op = predicate?.operator;\n  const path = predicate?.path;\n  const expected = predicate?.value;\n\n  // Root lets your rules use paths like \"deviceId\" or \"data.body\" or \"meta.device.id\"\n  const predicateRoot = { ...event.body, data: event.body.data, meta };\n  const actual = getByPath(predicateRoot, path);\n\n  log('predicate:', { path, op, expected, actual });\n\n  switch (op) {\n    case 'equals':\n      return normalizeEquals(actual, expected);\n\n    case 'not_equals':\n      return !normalizeEquals(actual, expected);\n\n    case 'includes': {\n      if (!isPresent(actual)) return false;\n      if (Array.isArray(actual)) return actual.includes(expected);\n      return normalizeIfString(String(actual)).includes(normalizeIfString(String(expected ?? '')));\n    }\n\n    case 'not_includes': {\n      if (!isPresent(actual)) return true;\n      if (Array.isArray(actual)) return !actual.includes(expected);\n      return !normalizeIfString(String(actual)).includes(normalizeIfString(String(expected ?? '')));\n    }\n\n    case 'starts_with':\n      return isPresent(actual) && normalizeIfString(String(actual)).startsWith(normalizeIfString(String(expected ?? '')));\n\n    case 'ends_with':\n      return isPresent(actual) && normalizeIfString(String(actual)).endsWith(normalizeIfString(String(expected ?? '')));\n\n    case 'matches_regex': {\n      if (!isPresent(actual)) return false;\n      try {\n        const re = new RegExp(normalizeIfString(String(expected ?? '')));\n        return re.test(normalizeIfString(String(actual)));\n      } catch {\n        throw new Error(`Invalid regex in predicate for path \"${path}\": ${normalizeIfString(String(expected))}`);\n      }\n    }\n\n    case 'gt':\n    case 'gte':\n    case 'lt':\n    case 'lte': {\n      const a = toComparableNumber(actual);\n      const b = toComparableNumber(expected);\n      log('numeric compare:', { op, a, b });\n      if (a === undefined || b === undefined) return false;\n      if (op === 'gt') return a > b;\n      if (op === 'gte') return a >= b;\n      if (op === 'lt') return a < b;\n      return a <= b;\n    }\n\n    case 'exists':\n      return isPresent(actual);\n\n    default:\n      throw new Error(`Unsupported predicate operator: ${op}`);\n  }\n};\n\nconst resolveRecipient = (recipientId, recipient) => {\n  log('--- resolveRecipient ---', recipientId);\n  log('recipient (redacted):', redact(recipient));\n\n  const allowedDeviceIds = Array.isArray(recipient.allowedDeviceIds) ? recipient.allowedDeviceIds : [];\n  log('allowedDeviceIds:', allowedDeviceIds);\n  if (allowedDeviceIds.length > 0 && !allowedDeviceIds.includes(deviceId)) {\n    log('SKIP: deviceId not allowed', { deviceId, allowedDeviceIds });\n    return null;\n  }\n\n  const allowedDataTypes = Array.isArray(recipient.allowedDataTypes) ? recipient.allowedDataTypes : [];\n  log('allowedDataTypes:', allowedDataTypes);\n  if (allowedDataTypes.length > 0 && !allowedDataTypes.includes(dataType)) {\n    log('SKIP: dataType not allowed', { dataType, allowedDataTypes });\n    return null;\n  }\n\n  const baseEndpointIds = Array.isArray(recipient.endpointIds) ? recipient.endpointIds : [];\n  const baseTemplateIds = Array.isArray(recipient.templateIds) ? recipient.templateIds : [];\n  log('baseEndpointIds:', baseEndpointIds);\n  log('baseTemplateIds:', baseTemplateIds);\n\n  const rules = Array.isArray(recipient.rules) ? recipient.rules : [];\n  log('rule count:', rules.length);\n\n  if (rules.length === 0) {\n    log('NO RULES: selecting recipient with base routing');\n    return { id: recipientId, ...recipient, endpointIds: baseEndpointIds, templateIds: baseTemplateIds };\n  }\n\n  const matchedRules = [];\n\n  for (const rule of rules) {\n    log('checking rule:', { ruleId: rule?.id, type: rule?.type });\n\n    if (rule?.type !== dataType) {\n      log('rule type mismatch, skip:', { ruleType: rule?.type, dataType });\n      continue;\n    }\n\n    const whens = Array.isArray(rule.when) ? rule.when : [];\n    log('when predicates:', whens);\n\n    const matched = whens.every((p, idx) => {\n      const ok = predicateMatches(p);\n      log(`predicate[${idx}] result:`, ok);\n      return ok;\n    });\n\n    log('rule matched?', matched, 'ruleId:', rule?.id);\n\n    if (!matched) continue;\n\n    // IMPORTANT: keep track of matches (you were missing this)\n    matchedRules.push(rule);\n  }\n\n  log('matchedRules ids:', matchedRules.map((r) => r.id));\n\n  if (matchedRules.length === 0) {\n    log('NO MATCHED RULES: dropping recipient');\n    return null;\n  }\n\n  return { \n    id: recipientId,\n    vars: recipient.vars,\n    rules: matchedRules.map((r) => {\n      return { id: r.id, then: r.then };\n    }),\n  };\n};\n\nlog('recipient ids:', recipientsFilteredGlobally.join(\", \"));\n\nconst resolvedRecipients = recipientsFilteredGlobally\n  .map((id) => resolveRecipient(id, config.recipients?.[id]))\n  .filter(Boolean);\n\nlog('resolvedRecipients count:', resolvedRecipients.length);\nlog('resolvedRecipients (redacted):', redact(resolvedRecipients));\n\nreturn [\n  {\n    json: {\n      event,\n      config,\n      recipientsResolved: resolvedRecipients\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -512,
        1504
      ],
      "id": "31f21db0-aeac-4170-bc9d-8fa5fc8b61a9",
      "name": "Filter recipients by recipient rules",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (Run Once for All Items)\n\n// Toggle this to silence logs quickly\nconst DEBUG = true;\n\nconst log = (...args) => {\n  if (DEBUG) console.log(\"[debug]\", ...args);\n};\n\nconst redact = (value) => {\n  const SECRET_KEY_RE = /(token|secret|password|apiKey|key)/i;\n\n  const walk = (v) => {\n    if (v == null) return v;\n    if (Array.isArray(v)) return v.map(walk);\n\n    if (typeof v === \"object\") {\n      const out = {};\n      for (const [k, child] of Object.entries(v)) {\n        if (SECRET_KEY_RE.test(k)) out[k] = \"***REDACTED***\";\n        else out[k] = walk(child);\n      }\n      return out;\n    }\n    return v;\n  };\n\n  return walk(value);\n};\n\nconst getByPath = (root, path) => {\n  if (!path || typeof path !== \"string\") return undefined;\n\n  // supports simple dot paths like: meta.createdAt, data.body, recipient.vars.botToken\n  const parts = path.split(\".\").filter(Boolean);\n  let cur = root;\n\n  for (const part of parts) {\n    if (cur == null) return undefined;\n    cur = cur[part];\n  }\n\n  return cur;\n};\n\nconst templateString = (input, templateData, renderedText) => {\n  if (typeof input !== \"string\") return input;\n\n  return input.replace(/\\{([^{}]+)\\}/g, (match, rawToken) => {\n    const token = String(rawToken).trim();\n\n    // Special placeholder: {%text%} => already-rendered template.text\n    if (token === \"%text%\") return String(renderedText ?? \"\");\n\n    const value = getByPath(templateData, token);\n\n    // If missing, keep placeholder as-is (non-strict)\n    if (value === undefined || value === null) return match;\n\n    // For non-primitives, stringify to avoid \"[object Object]\"\n    if (typeof value === \"object\") return JSON.stringify(value);\n\n    return String(value);\n  });\n};\n\nconst templateDeepOnlyStrings = (value, templateData, renderedText) => {\n  if (typeof value === \"string\") return templateString(value, templateData, renderedText);\n\n  if (Array.isArray(value)) {\n    return value.map((v) => templateDeepOnlyStrings(v, templateData, renderedText));\n  }\n\n  if (value && typeof value === \"object\") {\n    const out = {};\n    for (const [k, v] of Object.entries(value)) {\n      out[k] = templateDeepOnlyStrings(v, templateData, renderedText);\n    }\n    return out;\n  }\n\n  return value;\n};\n\nconst items = $input.all().map((item) => {\n  const wrapper = item.json;\n  \n  const config = wrapper.config;\n  const event = wrapper.event;\n\n  const templateData = wrapper.templateData;\n  const toTemplate = wrapper.toTemplate;\n\n  if (!templateData) throw new Error(\"Missing templateData\");\n  if (!toTemplate) throw new Error(\"Missing toTemplate\");\n  if (!toTemplate?.template?.text) throw new Error(\"Missing toTemplate.template.text\");\n  if (!toTemplate?.endpoint) throw new Error(\"Missing toTemplate.endpoint\");\n\n  // 1) Render template.text first (only uses templateData)\n  const renderedText = templateString(toTemplate.template.text, templateData, \"\");\n\n  // 2) Template ONLY within toTemplate (strings only), using templateData,\n  //    with {%text%} resolved from the rendered template.text above.\n  const templatedEndpoint = templateDeepOnlyStrings(\n    toTemplate.endpoint,\n    templateData,\n    renderedText\n  );\n\n  // 3) Build \"toSend\" as a flattened, templated endpoint (no nesting)\n  //    Keep everything else as-is; just add toSend.\n  const toSend = {\n    method: templatedEndpoint.method,\n    url: templatedEndpoint.url,\n    headers: templatedEndpoint.headers ?? {},\n    searchParams: templatedEndpoint.searchParams ?? {},\n    timeoutMs: templatedEndpoint.timeoutMs,\n    body:\n      templatedEndpoint?.body?.type === \"json\"\n        ? (templatedEndpoint.body?.content ?? {})\n        : templatedEndpoint?.body?.content ?? templatedEndpoint?.body,\n  };\n\n  log(\"Rendered text preview:\", renderedText);\n  log(\"toSend (redacted):\", redact(toSend));\n\n  return {\n    json: {\n      event,\n      config,\n      toSend,\n    },\n  };\n});\n\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        1504
      ],
      "id": "0daf0cac-4e93-46d7-8dc8-27834dc36294",
      "name": "Template messages",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (Run Once for All Items)\n// Filters recipients by allowedDeviceIds / allowedDataTypes ONLY when those props exist.\n\nconst wrapper = $input.first().json;\nconst config = wrapper.config;\nconst event = wrapper.event;\n\nif (!config?.recipients) throw new Error('Missing config.recipients');\nif (!event?.body?.device?.id) throw new Error('Missing event.body.device.id');\nif (!event?.body?.data?.type) throw new Error('Missing event.body.data.type');\n\nconst deviceId = event.body.device.id;\nconst dataType = event.body.data.type;\n\n\nconst isNotDisabled = (recipient) => {\n  if (recipient.disabled === true) return false;\n  return true;\n};\n\nconst isAllowed = (recipient) => {\n  // If prop is missing/null => do NOT filter by it (recipient remains)\n  if (Array.isArray(recipient.allowedDeviceIds) && recipient.allowedDeviceIds.length > 0) {\n    if (!recipient.allowedDeviceIds.includes(deviceId)) return false;\n  }\n\n  if (Array.isArray(recipient.allowedDataTypes) && recipient.allowedDataTypes.length > 0) {\n    if (!recipient.allowedDataTypes.includes(dataType)) return false;\n  }\n\n  return true;\n};\n\nconst out = Object.entries(config.recipients)\n  .filter(([, recipient]) => isNotDisabled(recipient))\n  .filter(([, recipient]) => isAllowed(recipient))\n  .map(([id, recipient]) => (id));\n\nreturn [\n  {\n    json: {\n      event,\n      config,\n      recipientsFilteredGlobally: out\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        1504
      ],
      "id": "94eb3b83-fab4-45d0-9510-2d4c138e0e91",
      "name": "Filter recipients by DeviceId and DataType filters"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (Run Once for All Items)\n\n// Toggle this to silence logs quickly\nconst DEBUG = true;\n\nconst log = (...args) => {\n  if (DEBUG) console.log(\"[debug]\", ...args);\n};\n\nconst redact = (value) => {\n  const SECRET_KEY_RE = /(token|secret|password|apiKey|key)/i;\n\n  const walk = (v) => {\n    if (v == null) return v;\n    if (Array.isArray(v)) return v.map(walk);\n\n    if (typeof v === \"object\") {\n      const out = {};\n      for (const [k, child] of Object.entries(v)) {\n        if (SECRET_KEY_RE.test(k)) out[k] = \"***REDACTED***\";\n        else out[k] = walk(child);\n      }\n      return out;\n    }\n\n    return v;\n  };\n\n  return walk(value);\n};\n\nlog(\"Input item count:\", $input.all().length);\n\nconst wrapper = $input.first().json;\nlog(\"Wrapper keys:\", Object.keys(wrapper ?? {}));\n\nconst config = wrapper.config;\nconst event = wrapper.event;\nconst recipientsResolved = wrapper.recipientsResolved;\n\nlog(\"Has config?\", !!config, \"Has event?\", !!event);\nlog(\"Config (redacted):\", redact(config));\nlog(\"Event keys:\", Object.keys(event ?? {}));\nlog(\"Event.body keys:\", Object.keys(event?.body ?? {}));\n\nif (!config) throw new Error(\"Missing config\");\nif (!event) throw new Error(\"Missing event\");\nif (!recipientsResolved) throw new Error(\"Missing RecipientsResolved\");\n\n// meta is what templates typically refer to as {meta.*}\nconst meta = {\n  id: event.body.id,\n  createdAt: event.body.createdAt,\n  deviceId: event.body.device.id,\n  source: event.body.source,\n  ...(event.body.meta ?? {}),\n};\nlog(\"meta:\", meta);\n\n/**\n * @type {Array<Object>}\n */\nconst recipients = recipientsResolved;\n\nlog(\"recipient ids:\", recipients.map((r) => r.id).flat().join(\", \"));\n\nfor (const recipient of recipientsResolved) {\n\n  const rulesFiltered = [...recipient.rules];\n\n  /**\n   * @type {Array<string>}\n   */\n  const recipientEndpointIds = config.recipients[recipient.id]?.endpointIds ?? [];\n  /**\n   * @type {Array<string>}\n   */\n  const recipientTemplateIds = config.recipients[recipient.id]?.templateIds ?? [];\n  for (const rule of recipient.rules) {\n    // filter rules by recipient.endpointIds (if any)\n    /**\n     * @type {Array<string>}\n     */\n    const ruleEndpointIds = [...rule.then.endpointIds];\n\n    if (recipientEndpointIds.length > 0 && ruleEndpointIds.length > 0) {\n      if (recipientEndpointIds.some(item => ruleEndpointIds.includes(item))) {\n        rule.then.endpointIds = ruleEndpointIds.filter(id => recipientEndpointIds.includes(id));\n        log(`Found matching endpoints for rule ${rule.id}:`, rule.then.endpointIds);\n      } else {\n        const index = rulesFiltered.findIndex(r => r.id === rule.id);\n        if (index > -1) {\n          log(`No matching endpoints for rule ${rule.id}, removing it`);\n          rulesFiltered.splice(index, 1);\n        }\n      }\n    }\n\n    // leave only unique\n    rule.then.endpointIds.splice(0, rule.then.endpointIds.length, ...new Set(rule.then.endpointIds));\n    \n    // filter rules by recipient.templateIds (if any)\n    /**\n     * @type {Array<string>}\n    */\n    const ruleTemplateIds = [...rule.then.templateIds];\n\n    if (recipientTemplateIds.length > 0 && ruleTemplateIds.length > 0) {\n      if (recipientTemplateIds.some(item => ruleTemplateIds.includes(item))) {\n        rule.then.templateIds = ruleTemplateIds.filter(id => recipientTemplateIds.includes(id));\n        log(`Found matching templates for rule ${rule.id}:`, rule.then.templateIds);\n      } else {\n        const index = rulesFiltered.findIndex(r => r.id === rule.id);\n        if (index > -1) {\n          log(`No matching templates for rule ${rule.id}, removing it`);\n          rulesFiltered.splice(index, 1);\n        }\n      }\n    }\n\n    // leave only unique\n    rule.then.templateIds.splice(0, rule.then.templateIds.length, ...new Set(rule.then.templateIds));\n\n    log(`Recipient ${recipient.id} filtered rules:`, recipient.rules.length, \"->\", rulesFiltered.length);\n\n    recipient.rules = rulesFiltered;\n  }\n}\n\n// Return RuntimeModel\nreturn [\n  {\n    json: {\n      event,\n      config,\n      recipientsResolved\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        1504
      ],
      "id": "6b05443e-d7af-4944-8a90-979da3d344c3",
      "name": "Filter rules by recipients endpointIds and templateIds",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.toSend.method }}",
                    "rightValue": "POST",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "eda2323a-bf78-4eb5-be11-f7e3abe9b155"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": false,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "cd76dc0d-3f7a-4a11-8e58-ff83dcff3c6e",
                    "leftValue": "={{ $json.toSend.method }}",
                    "rightValue": "GET",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {
          "ignoreCase": true
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        -928,
        1808
      ],
      "id": "33168e35-b75c-4ba9-b075-32a63c33391f",
      "name": "Switch"
    },
    {
      "parameters": {
        "method": "={{ $json.toSend.method }}",
        "url": "={{ $json.toSend.url }}",
        "sendQuery": true,
        "specifyQuery": "json",
        "jsonQuery": "={{ JSON.stringify($json.toSend.searchParams ?? {}) }}",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "={{ JSON.stringify($json.toSend.headers ?? {}) }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.toSend.body }}",
        "options": {}
      },
      "id": "4be75843-fbff-45a7-9e11-b5815a312c0f",
      "name": "Send to Telegram (POST)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -720,
        1728
      ]
    },
    {
      "parameters": {
        "method": "={{ $json.toSend.method }}",
        "url": "={{ $json.toSend.url }}",
        "sendQuery": true,
        "specifyQuery": "json",
        "jsonQuery": "={{ JSON.stringify($json.toSend.searchParams) }}",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "={{ JSON.stringify($json.toSend.headers) }}",
        "options": {}
      },
      "id": "5684aafa-48a8-49a7-8150-3efba6f37a44",
      "name": "Send to Telegram (GET)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -720,
        1888
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $json.headers[\"x-n8n-device-relay\"] }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -784,
        576
      ],
      "id": "ada8bbc8-9e36-4c8d-b899-f46a5ea78169",
      "name": "If"
    },
    {
      "parameters": {
        "errorMessage": "No token specified!"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        -416,
        592
      ],
      "id": "f76013bb-9014-4126-9e3e-53c8241e1b8b",
      "name": "Stop and Error"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $input.all().length }}",
              "rightValue": 2,
              "operator": {
                "type": "number",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -928,
        1152
      ],
      "id": "c3f42e23-a92e-4a37-b5ea-899194cb9722",
      "name": "Validate config presence"
    },
    {
      "parameters": {
        "errorMessage": "No config or webhook data are present"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        -720,
        1328
      ],
      "id": "6c12c28f-7a7d-4398-bcac-9eb12fa9e055",
      "name": "Stop and Error - config presence"
    },
    {
      "parameters": {
        "errorMessage": "No tokens in config"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        -512,
        1328
      ],
      "id": "e8abbad6-4c3a-4045-bded-a776e5c9540a",
      "name": "Stop and Error - config tokens length"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $input.all()[1].json.tokens.length\n}}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -720,
        1152
      ],
      "id": "c32c49b4-f799-43fe-99a0-134f605dbc43",
      "name": "Validate config tokens length"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $input.all()[1].json.tokens.some(tokenObj =>\n  tokenObj.key === $input.all()[0].json.headers[\"x-n8n-device-relay\"]\n) }}",
              "rightValue": 1,
              "operator": {
                "type": "boolean",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -512,
        1152
      ],
      "id": "c58dbfee-72cb-46de-856a-0c3376505ad9",
      "name": "Validate config token"
    },
    {
      "parameters": {
        "errorMessage": "Provided token does not exist"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        -304,
        1328
      ],
      "id": "02a1f61a-636c-4949-ad34-883fe16febb9",
      "name": "Stop and Error - validate config token"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $input.all()[0].json.body.data.type }}",
              "rightValue": 1,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            },
            {
              "id": "c40abd2c-cc8f-4a9b-b111-161e8c200f76",
              "leftValue": "={{ $input.all()[0].json.body.data.type }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -96,
        1152
      ],
      "id": "2a769c52-e96f-47c9-aa98-e6252600ceed",
      "name": "Validate config data type"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $input.all()[0].json.body.device.id }}",
              "rightValue": 1,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            },
            {
              "id": "c40abd2c-cc8f-4a9b-b111-161e8c200f76",
              "leftValue": "={{ $input.all()[0].json.body.device.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        112,
        1152
      ],
      "id": "41afb293-7b77-4066-8ffa-9d72a098541f",
      "name": "Validate config device id"
    },
    {
      "parameters": {
        "errorMessage": "data type does not exist or empty"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        112,
        1328
      ],
      "id": "65bd2d6f-9676-4fcd-b8e5-070dd4ae4bfe",
      "name": "Stop and Error - validate data type in event"
    },
    {
      "parameters": {
        "errorMessage": "No Device ID provided"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        320,
        1328
      ],
      "id": "3b1e6b66-d7a9-474e-843b-b2555e88ddcc",
      "name": "Stop and Error - validate device id in event"
    },
    {
      "parameters": {
        "content": "## Edit the config variable there ->\n"
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -928,
        720
      ],
      "typeVersion": 1,
      "id": "307fee8e-3103-4805-9221-1ab65ed623f4",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "// 0) Validate webhook payload type\nconst all = $input.all();\n\nconst eventItem = all[0].json;   // from Webhook\nconst configItem = all[1].json;  // from config node\n\nreturn [\n  {\n    json: {\n      event: eventItem,\n      config: configItem\n    }\n  }\n];\n"
      },
      "id": "ee4aad4d-42bf-45e0-b640-d713823be8ff",
      "name": "Remap objects",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -928,
        1504
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $input.all()[1].json.tokens.find(tokenObj =>\n  tokenObj.name === $input.all()[0].json.body.device.id\n).key }}",
              "rightValue": "={{ $input.all()[0].json.headers[\"x-n8n-device-relay\"] }}",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -304,
        1152
      ],
      "id": "1e821894-7d68-400f-97ae-0aecf6bad7f3",
      "name": "Validate config token per device"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $input.all()[1].json.tokens.find(tokenObj =>\n  tokenObj.name.toLowerCase() === \"debug\").key }}",
              "rightValue": "={{ $input.all()[0].json.headers[\"x-n8n-device-relay\"] }}",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -304,
        960
      ],
      "id": "d636b1ee-8975-44c5-a78d-c86e3aec97ac",
      "name": "Is not debug device token"
    },
    {
      "parameters": {
        "errorMessage": "Token does not match with defined device"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        -96,
        1328
      ],
      "id": "eb56d3e8-15e4-41d7-8f2e-47cea9ebaab3",
      "name": "Stop and Error - validate config per device"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "2f835c8c-13fa-49f9-b5d9-922d92154be7",
              "name": "step",
              "value": "initial",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        64,
        336
      ],
      "id": "0c7b3342-3974-45c5-b3bb-6264730ff09f",
      "name": "Step value: initial",
      "executeOnce": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        896,
        80
      ],
      "id": "6d2518c9-7369-4a7b-a310-5dc72b350f4d",
      "name": "Merge after step and config check"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "9095153c-1228-4fe9-934f-1c59c362b3a8",
              "leftValue": "={{ $input.all()[1].json.logIngestions }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "exists",
                "singleValue": true
              }
            },
            {
              "id": "b4c8d7f7-6b71-4076-8b4d-d489ef7a766b",
              "leftValue": "={{ $json.config.logIngestions }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        64,
        192
      ],
      "id": "554117ab-b1a7-46d3-8e87-fbab4f0a4f7f",
      "name": "If logIngestions exists"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "2f835c8c-13fa-49f9-b5d9-922d92154be7",
              "name": "step",
              "value": "config_validated",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        192,
        496
      ],
      "id": "14e5c4f6-483b-4087-99a0-fc56b38dab9d",
      "name": "Step value: config_validated",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000012",
              "name": "step",
              "value": "validate_tokens_length",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        336,
        656
      ],
      "id": "dbcafb79-03ad-435d-957a-788ce6a3b6b6",
      "name": "Step value: validate_tokens_length",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000013",
              "name": "step",
              "value": "validate_config_token",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        480,
        800
      ],
      "id": "9a169781-d208-48d0-afcf-473df085a3a1",
      "name": "Step value: validate_config_token",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000014",
              "name": "step",
              "value": "validate_device_token",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        608,
        928
      ],
      "id": "2ddb66e0-69ca-4f22-9368-522505c724b5",
      "name": "Step value: validate_device_token",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000015",
              "name": "step",
              "value": "validate_debug_token",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        752,
        1040
      ],
      "id": "0c770eff-a267-4872-977b-a2092970a2c0",
      "name": "Step value: validate_debug_token",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000016",
              "name": "step",
              "value": "validate_data_type",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        880,
        1152
      ],
      "id": "22e04ca7-ffe1-4ef5-aa55-31d0e9c0781d",
      "name": "Step value: validate_data_type",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000017",
              "name": "step",
              "value": "validate_device_id",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        992,
        1264
      ],
      "id": "ff079fe2-0186-4e8d-963e-4a1d58be7701",
      "name": "Step value: validate_device_id",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000018",
              "name": "step",
              "value": "step_remap_objects",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1120,
        1376
      ],
      "id": "2eb37b01-7613-4007-ac83-75f996e125fa",
      "name": "Step value: step_remap_objects",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000019",
              "name": "step",
              "value": "step_filter_recipients_by_deviceid_datatype",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1264,
        1488
      ],
      "id": "fb713200-e4ad-4b63-8cb0-316a572c1801",
      "name": "Step value: step_filter_recipients_by_deviceid_datatype",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-00000000001a",
              "name": "step",
              "value": "step_filter_recipients_by_rules",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1392,
        1600
      ],
      "id": "5bdd9adc-906c-4d34-9adf-601e78c081b7",
      "name": "Step value: step_filter_recipients_by_rules",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-00000000001b",
              "name": "step",
              "value": "step_filter_recipients_by_endpointids_templateids",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1504,
        1712
      ],
      "id": "8b8f7a3c-9ad2-4fe9-b4e3-27a86672b7a6",
      "name": "Step value: step_filter_recipients_by_endpointids_templateids",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-00000000001c",
              "name": "step",
              "value": "step_form_outbound",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1632,
        1808
      ],
      "id": "c6a16e06-aab0-47a2-9864-3593a1ace714",
      "name": "Step value: step_form_outbound",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-00000000001d",
              "name": "step",
              "value": "step_compose_messages",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1760,
        1920
      ],
      "id": "9ed35c59-d8b2-433f-929a-2efb19ab03f7",
      "name": "Step value: step_compose_messages",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-00000000001e",
              "name": "step",
              "value": "step_template_messages",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1904,
        2032
      ],
      "id": "f6d917ea-3a7e-40b0-ae1a-a246045f45a3",
      "name": "Step value: step_template_messages",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-00000000001f",
              "name": "step",
              "value": "send_message",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2048,
        2128
      ],
      "id": "97cecaa6-4ce3-4862-83e0-53a745d22f54",
      "name": "Step value: send_message",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "00000000-0000-4000-8000-000000000020",
              "name": "step",
              "value": "send_message_after",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2160,
        2224
      ],
      "id": "847a22a0-016b-4c78-9d13-18fbf9517f19",
      "name": "Step value: send_message_after",
      "executeOnce": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ $input.all().length }}",
              "rightValue": 2,
              "operator": {
                "type": "number",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1168,
        80
      ],
      "id": "46170573-fac6-433d-86f8-4c04874aa504",
      "name": "Validate body and step presence"
    },
    {
      "parameters": {
        "content": "This is an optional log ingestion workflow to send telemetry and logs to an HTTP endpoint. It will be skipped if there is no `.logIngestion` property in JSON config.",
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1,
      "id": "65f356d3-01a2-4951-99a6-e9fbf46e4484",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "4d08dd15-fd42-4c1d-9d7a-32f7a00f5a9f",
              "leftValue": "={{ Object.keys($input.all()[0].json.config.logIngestions || {}).length > 0 }}",
              "rightValue": 2,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1392,
        80
      ],
      "id": "8c1d22d4-a1d1-4557-b45f-53eec6556f14",
      "name": "Validate logIngestions length"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "Zd5JbqHzxPcdZhM6",
          "mode": "list",
          "cachedResultUrl": "/workflow/Zd5JbqHzxPcdZhM6",
          "cachedResultName": "LogIngestion in Device Relay by Kenya-West (example)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "logIngestions": "={{ $json.logIngestions }}",
            "step": "={{ $json.step }}",
            "event": "={{ $json.event }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "event",
              "displayName": "event",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "logIngestions",
              "displayName": "logIngestions",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "step",
              "displayName": "step",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1808,
        80
      ],
      "name": "Call LogIngestion in Device Relay by Kenya-West",
      "id": "7158a3a1-0a12-41af-8ddd-296a62378374",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const all = $input.all();\n\nconst eventItem = all[0].json.event;\nconst configItem = all[0].json.config;\nconst step = all[1].json.step;\n\nreturn [\n  {\n    json: {\n      event: eventItem,\n      config: configItem,\n      logIngestions: configItem.logIngestions,\n      step\n    }\n  }\n];\n"
      },
      "id": "03eaf168-509d-4511-b247-e713cd04c0f8",
      "name": "Remap logIngestion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        80
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Validate config presence",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: initial",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Config": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Form outbound": {
      "main": [
        [
          {
            "node": "Compose messages",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: step_form_outbound",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compose messages": {
      "main": [
        [
          {
            "node": "Template messages",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: step_compose_messages",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter recipients by recipient rules": {
      "main": [
        [
          {
            "node": "Filter rules by recipients endpointIds and templateIds",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: step_filter_recipients_by_rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Template messages": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: step_template_messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter recipients by DeviceId and DataType filters": {
      "main": [
        [
          {
            "node": "Filter recipients by recipient rules",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: step_filter_recipients_by_deviceid_datatype",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter rules by recipients endpointIds and templateIds": {
      "main": [
        [
          {
            "node": "Form outbound",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: step_filter_recipients_by_endpointids_templateids",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Send to Telegram (POST)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send to Telegram (GET)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Telegram (POST)": {
      "main": [
        [
          {
            "node": "Step value: send_message_after",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Telegram (GET)": {
      "main": [
        [
          {
            "node": "Step value: send_message_after",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Config",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Stop and Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate config presence": {
      "main": [
        [
          {
            "node": "Validate config tokens length",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Stop and Error - config presence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate config tokens length": {
      "main": [
        [
          {
            "node": "Validate config token",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: validate_tokens_length",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Stop and Error - config tokens length",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate config token": {
      "main": [
        [
          {
            "node": "Is not debug device token",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: validate_config_token",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Stop and Error - validate config token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate config data type": {
      "main": [
        [
          {
            "node": "Validate config device id",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: validate_data_type",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Stop and Error - validate data type in event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate config device id": {
      "main": [
        [
          {
            "node": "Remap objects",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: validate_device_id",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Stop and Error - validate device id in event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remap objects": {
      "main": [
        [
          {
            "node": "Filter recipients by DeviceId and DataType filters",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: step_remap_objects",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate config token per device": {
      "main": [
        [
          {
            "node": "Validate config data type",
            "type": "main",
            "index": 0
          },
          {
            "node": "If logIngestions exists",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: validate_device_token",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Stop and Error - validate config per device",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is not debug device token": {
      "main": [
        [
          {
            "node": "Validate config token per device",
            "type": "main",
            "index": 0
          },
          {
            "node": "Step value: validate_debug_token",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validate config data type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Step value: initial": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge after step and config check": {
      "main": [
        [
          {
            "node": "Validate body and step presence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If logIngestions exists": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Step value: config_validated": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: validate_tokens_length": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: validate_config_token": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: validate_device_token": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: validate_debug_token": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: validate_data_type": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: validate_device_id": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: step_remap_objects": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: step_filter_recipients_by_deviceid_datatype": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: step_filter_recipients_by_rules": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: step_filter_recipients_by_endpointids_templateids": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: step_form_outbound": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: step_compose_messages": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: step_template_messages": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: send_message": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Step value: send_message_after": {
      "main": [
        [
          {
            "node": "Merge after step and config check",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Validate body and step presence": {
      "main": [
        [
          {
            "node": "Validate logIngestions length",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate logIngestions length": {
      "main": [
        [
          {
            "node": "Remap logIngestion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remap logIngestion": {
      "main": [
        [
          {
            "node": "Call LogIngestion in Device Relay by Kenya-West",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": ""
  }
}